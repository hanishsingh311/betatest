// Generated by CoffeeScript 1.11.0
var TaskGroup, balUtilFlow, eachr, typeChecker,
  slice = [].slice;

TaskGroup = require('taskgroup').TaskGroup;

typeChecker = require('typechecker');

eachr = require('eachr');

balUtilFlow = {
  wait: function(delay, fn) {
    return setTimeout(fn, delay);
  },
  flow: function() {
    var action, actions, args, next, object, ref, ref1, ref2, tasks;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (args.length === 1) {
      ref = args[0], object = ref.object, actions = ref.actions, action = ref.action, args = ref.args, tasks = ref.tasks, next = ref.next;
    } else if (args.length === 4) {
      ref1 = args, object = ref1[0], action = ref1[1], args = ref1[2], next = ref1[3];
    } else if (args.length === 3) {
      ref2 = args, actions = ref2[0], args = ref2[1], next = ref2[2];
    }
    if ((action != null) === false && (actions != null) === false) {
      throw new Error('balUtilFlow.flow called without any action');
    }
    if (actions == null) {
      actions = action.split(/[,\s]+/g);
    }
    if (object == null) {
      object = null;
    }
    tasks || (tasks = new TaskGroup().done(next));
    actions.forEach(function(action) {
      return tasks.addTask(function(complete) {
        var argsClone, fn;
        argsClone = (args || []).slice();
        argsClone.push(complete);
        fn = typeChecker.isFunction(action) ? action : object[action];
        return fn.apply(object, argsClone);
      });
    });
    tasks.run();
    return this;
  },
  createSnore: function(message, opts) {
    var snore;
    opts || (opts = {});
    if (opts.delay == null) {
      opts.delay = 5000;
    }
    snore = {
      snoring: false,
      timer: setTimeout(function() {
        snore.clear();
        snore.snoring = true;
        return typeof message === "function" ? message() : void 0;
      }, opts.delay),
      clear: function() {
        if (snore.timer) {
          clearTimeout(snore.timer);
          return snore.timer = false;
        }
      }
    };
    return snore;
  },
  suffixArray: function() {
    var arg, args, i, item, j, len, len1, result, suffix;
    suffix = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    result = [];
    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      if (!typeChecker.isArray(arg)) {
        arg = [arg];
      }
      for (j = 0, len1 = arg.length; j < len1; j++) {
        item = arg[j];
        result.push(item + suffix);
      }
    }
    return result;
  }
};

module.exports = balUtilFlow;
