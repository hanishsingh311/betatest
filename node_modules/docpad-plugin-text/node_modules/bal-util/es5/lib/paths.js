// Generated by CoffeeScript 1.11.0
var PassThrough, TaskGroup, balUtilFlow, balUtilPaths, eachr, extendr, extractOpts, ignorefs, pathUtil, safefs, scandir, typeChecker,
  slice = [].slice;

pathUtil = require('path');

eachr = require('eachr');

typeChecker = require('typechecker');

extendr = require('extendr');

safefs = require('safefs');

PassThrough = require('stream').PassThrough;

extractOpts = require('extract-opts');

TaskGroup = require('taskgroup').TaskGroup;

balUtilFlow = require('./flow');

ignorefs = require('ignorefs');

scandir = require('scandirectory');

balUtilPaths = {
  resolveCaseSensitivePath: function(path, next) {
    var parentPath;
    parentPath = safefs.getParentPathSync(path) || '/';
    if (parentPath === '/') {
      return next(null, parentPath);
    }
    safefs.resolveCaseSensitivePath(parentPath, function(err, parentPath) {
      return safefs.readdir(parentPath, function(err, files) {
        var file, i, len, relativePathLowerCase;
        if (err) {
          return next(err);
        }
        relativePathLowerCase = relativePath.toLowerCase();
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          if (file.toLowerCase() === relativePathLowerCase) {
            return next(null, pathUtil.join(parentPath, relativePath));
          }
        }
        err = new Error("Could not find the path " + relativePath + " inside " + parentPath);
        return next(err);
      });
    });
    return safefs;
  },
  cp: function(src, dst, next) {
    safefs.readFile(src, 'binary', function(err, data) {
      if (err) {
        return next(err);
      }
      return safefs.writeFile(dst, data, 'binary', function(err) {
        return next(err);
      });
    });
    return this;
  },
  prefixPathSync: function(path, parentPath) {
    path = path.replace(/[\/\\]$/, '');
    if (/^([a-zA-Z]\:|\/)/.test(path) === false) {
      path = pathUtil.join(parentPath, path);
    }
    return path;
  },
  isDirectory: function(path, next) {
    if ((path != null ? path.isDirectory : void 0) != null) {
      return next(null, path.isDirectory(), path);
    } else {
      safefs.stat(path, function(err, stat) {
        if (err) {
          return next(err);
        }
        return next(null, stat.isDirectory(), stat);
      });
    }
    return this;
  },
  generateSlugSync: function(path) {
    var result;
    result = path.replace(/[^a-zA-Z0-9]/g, '-').replace(/^-/, '').replace(/-+/, '-');
    return result;
  },
  scanlist: function(path, next) {
    scandir({
      path: path,
      readFiles: true,
      ignoreHiddenFiles: true,
      next: function(err, list) {
        return next(err, list);
      }
    });
    return this;
  },
  scantree: function(path, next) {
    scandir({
      path: path,
      readFiles: true,
      ignoreHiddenFiles: true,
      next: function(err, list, tree) {
        return next(err, tree);
      }
    });
    return this;
  },
  cpdir: function() {
    var args, err, i, len, next, opt, opts, outPath, ref, scandirOpts, srcPath;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    opts = {};
    if (args.length === 1) {
      opts = args[0];
    } else if (args.length >= 3) {
      srcPath = args[0], outPath = args[1], next = args[2];
      opts = {
        srcPath: srcPath,
        outPath: outPath,
        next: next
      };
    } else {
      err = new Error('balUtilPaths.cpdir: unknown arguments');
      if (next) {
        return next(err);
      } else {
        throw err;
      }
    }
    scandirOpts = {
      path: opts.srcPath,
      fileAction: function(fileSrcPath, fileRelativePath, next) {
        var fileOutPath;
        fileOutPath = pathUtil.join(opts.outPath, fileRelativePath);
        return safefs.ensurePath(pathUtil.dirname(fileOutPath), function(err) {
          if (err) {
            return next(err);
          }
          return balUtilPaths.cp(fileSrcPath, fileOutPath, function(err) {
            return next(err);
          });
        });
      },
      next: opts.next
    };
    ref = ['ignorePaths', 'ignoreHiddenFiles', 'ignoreCommonPatterns', 'ignoreCustomPatterns'];
    for (i = 0, len = ref.length; i < len; i++) {
      opt = ref[i];
      scandirOpts[opt] = opts[opt];
    }
    scandir(scandirOpts);
    return this;
  },
  rpdir: function() {
    var args, err, i, len, next, opt, opts, outPath, ref, scandirOpts, srcPath;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    opts = {};
    if (args.length === 1) {
      opts = args[0];
    } else if (args.length >= 3) {
      srcPath = args[0], outPath = args[1], next = args[2];
      opts = {
        srcPath: srcPath,
        outPath: outPath,
        next: next
      };
    } else {
      err = new Error('balUtilPaths.cpdir: unknown arguments');
      if (next) {
        return next(err);
      } else {
        throw err;
      }
    }
    scandirOpts = {
      path: opts.srcPath,
      fileAction: function(fileSrcPath, fileRelativePath, next) {
        var fileOutPath;
        fileOutPath = pathUtil.join(opts.outPath, fileRelativePath);
        return safefs.ensurePath(pathUtil.dirname(fileOutPath), function(err) {
          if (err) {
            return next(err);
          }
          return balUtilPaths.isPathOlderThan(fileOutPath, fileSrcPath, function(err, older) {
            if (older === true || older === null) {
              return balUtilPaths.cp(fileSrcPath, fileOutPath, function(err) {
                return next(err);
              });
            } else {
              return next();
            }
          });
        });
      },
      next: opts.next
    };
    ref = ['ignorePaths', 'ignoreHiddenFiles', 'ignoreCommonPatterns', 'ignoreCustomPatterns'];
    for (i = 0, len = ref.length; i < len; i++) {
      opt = ref[i];
      scandirOpts[opt] = opts[opt];
    }
    scandir(scandirOpts);
    return this;
  },
  writetree: function(dstPath, tree, next) {
    safefs.ensurePath(dstPath, function(err) {
      var tasks;
      if (err) {
        return next(err);
      }
      tasks = new TaskGroup({
        concurrency: 0
      }).done(next);
      eachr(tree, function(value, fileRelativePath) {
        return tasks.addTask(function(complete) {
          var fileFullPath;
          fileFullPath = pathUtil.join(dstPath, fileRelativePath.replace(/^\/+/, ''));
          if (typeChecker.isObject(value)) {
            return balUtilPaths.writetree(fileFullPath, value, complete);
          } else {
            return safefs.writeFile(fileFullPath, value, complete);
          }
        });
      });
      return tasks.run();
    });
    return this;
  },
  readPath: function(filePath, opts, next) {
    var base, base1, err, http, ref, ref1, req, requestOpts, zlib;
    ref = extractOpts(opts, next), opts = ref[0], next = ref[1];
    if (/^http/.test(filePath)) {
      zlib = null;
      try {
        zlib = require('zlib');
      } catch (error) {
        err = error;
      }
      requestOpts = require('url').parse(filePath);
      if (requestOpts.path == null) {
        requestOpts.path = requestOpts.pathname;
      }
      if (requestOpts.method == null) {
        requestOpts.method = 'GET';
      }
      if (requestOpts.headers == null) {
        requestOpts.headers = {};
      }
      if (zlib) {
        if ((base = requestOpts.headers)['accept-encoding'] == null) {
          base['accept-encoding'] = 'gzip,deflate';
        }
      }
      if ((base1 = requestOpts.headers)['user-agent'] == null) {
        base1['user-agent'] = 'Wget/1.14 (linux-gnu)';
      }
      http = requestOpts.protocol === 'https:' ? require('https') : require('http');
      req = http.request(requestOpts);
      if (req.setTimeout == null) {
        req.setTimeout = function(delay) {
          var onTimeout;
          onTimeout = function() {
            return req.emit('error', new Error('request timed out'));
          };
          return setTimeout(onTimeout, delay);
        };
      }
      req.setTimeout((ref1 = opts.timeout) != null ? ref1 : 10 * 1000);
      req.once('error', next);
      req.once('timeout', function() {
        return req.abort();
      });
      req.once('response', function(res) {
        var chunks, locationHeader, ref2;
        locationHeader = ((ref2 = res.headers) != null ? ref2.location : void 0) || null;
        if (locationHeader && locationHeader !== requestOpts.href) {
          req.removeAllListeners();
          balUtilPaths.readPath(locationHeader, opts, next);
          return;
        }
        chunks = [];
        res.on('data', function(chunk) {
          return chunks.push(chunk);
        });
        return res.once('end', function() {
          var data;
          data = new Buffer.concat(chunks);
          switch (res.headers['content-encoding']) {
            case 'gzip':
              zlib.unzip(data, next);
              break;
            case 'deflate':
              zlib.inflate(data, next);
              break;
            default:
              return next(null, data);
          }
        });
      });
      req.end();
    } else {
      safefs.readFile(filePath, function(err, data) {
        if (err) {
          return next(err);
        }
        return next(null, data);
      });
    }
    return this;
  },
  empty: function(filePath, next) {
    safefs.exists(filePath, function(exists) {
      if (!exists) {
        return next(null, true);
      }
      return safefs.stat(filePath, function(err, stat) {
        if (err) {
          return next(err);
        }
        return next(null, stat.size === 0);
      });
    });
    return this;
  },
  isPathOlderThan: function(aPath, bInput, next) {
    var bMtime, bPath, mode;
    bMtime = null;
    if (typeChecker.isNumber(bInput)) {
      mode = 'time';
      bMtime = new Date(new Date() - bInput);
    } else {
      mode = 'path';
      bPath = bInput;
    }
    balUtilPaths.empty(aPath, function(err, empty) {
      if (empty || err) {
        return next(err, null);
      }
      return safefs.stat(aPath, function(err, aStat) {
        var compare;
        if (err) {
          return next(err);
        }
        compare = function() {
          var older;
          if (aStat.mtime < bMtime) {
            older = true;
          } else {
            older = false;
          }
          return next(null, older);
        };
        if (mode === 'path') {
          return balUtilPaths.empty(bPath, function(err, empty) {
            if (empty || err) {
              return next(err, null);
            }
            return safefs.stat(bPath, function(err, bStat) {
              if (err) {
                return next(err);
              }
              bMtime = bStat.mtime;
              return compare();
            });
          });
        } else {
          return compare();
        }
      });
    });
    return this;
  }
};

module.exports = balUtilPaths;
